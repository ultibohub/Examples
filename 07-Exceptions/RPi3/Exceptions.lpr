program Exceptions;

{$mode objfpc}{$H+}

{ Example 07 Exceptions                                                        }
{                                                                              }
{  This example demonstrates both software generated and hardware generated    }
{  exceptions.                                                                 }
{                                                                              }
{  Exceptions provide a powerful way to control the program flow when errors   }
{  occur and used correctly can make your program more reliable.               }
{                                                                              }
{  To compile the example select Run, Compile (or Run, Build) from the menu.   }
{                                                                              }
{  Once compiled copy the kernel7.img file to an SD card along with the        }
{  firmware files and use it to boot your Raspberry Pi.                        }
{                                                                              }
{  Raspberry Pi 3B/3B+/3A+/Zero2W version                                      }
{   What's the difference? See Project, Project Options, Config and Target.    }

{Declare some units used by this example.}
uses
  GlobalConst,
  GlobalTypes,
  Platform,
  Threads,
  Console,
  Framebuffer,
  BCM2837,
  BCM2710,
  SysUtils;

{We need a simple record for our example}
type
 TSimpleRecord = record
  Value1:LongWord;
  Value2:LongWord;
 end;
 {And a pointer type to access our record}
 PSimpleRecord = ^TSimpleRecord;

{A window handle and some other variables.}
var
 Value:Integer;
 Data:PSimpleRecord;
 Dummy:function(Value:Integer):Pointer;

 WindowHandle:TWindowHandle;


begin
 {Create our console window}
 WindowHandle:=ConsoleWindowCreate(ConsoleDeviceGetDefault,CONSOLE_POSITION_FULL,True);

 {Output a welcome message}
 ConsoleWindowWriteLn(WindowHandle,'Welcome to Example 07 Exceptions');
 ConsoleWindowWriteLn(WindowHandle,'');

 {Let's look at a simple software exception first, exception handling happens within
  a try..except block. Anytime an exception occurs within a try..except block the
  exception handler in the RTL will skip immediately to the except block and do
  whatever is written there.}
 try
  {Now we have started a try..except block, let's create an exception. If we call
   the StrToInt() function and pass something that is not a number it will raise
   an exception for us to handle.}
  ConsoleWindowWriteLn(WindowHandle,'Trying StrToInt(A)');
  Value:=StrToInt('A');

  {This line won't ever be executed because the call to StrToInt() will raise an
   exception, but if we put it here it stops the compiler from saying that Value
   is assigned but not used.}
  ConsoleWindowWriteLn(WindowHandle,'The result of StrToInt(A) is ' + IntToStr(Value));
 except
  {This is where we will come to next after the exception is raised above, we can print
   the details of the exception to the screen so that we know what happened.}
  on E: Exception do
   begin
    ConsoleWindowWriteLn(WindowHandle,'An exception happened at address ' + IntToHex(PtrUInt(ExceptAddr),8) + ' the message was ' + E.Message);
    ConsoleWindowWriteLn(WindowHandle,'');
   end;
 end;

 {So what about hardware exceptions that are generated by the CPU? Ultibo supports
  them as well, let's try to generate a hardware exception by writing to a pointer
  that is not assigned to anything. First start our try..except block.}
 try
  {If we assign a pointer the value nil then it is considered to be unassigned.}
  Data:=nil;

  {When we try to write to one of the values in our nil record, the CPU will raise
   an exception which we can handle below}
  ConsoleWindowWriteLn(WindowHandle,'Trying Data.Value1:=12345');
  Data^.Value1:=12345;

  {This line won't ever be executed}
  ConsoleWindowWriteLn(WindowHandle,'Data.Value1:=12345 Success !');
 except
  {We should be here after our exception is raised, print to the screen to see}
  on E: Exception do
   begin
    ConsoleWindowWriteLn(WindowHandle,'An exception happened at address ' + IntToHex(PtrUInt(ExceptAddr),8) + ' the message was ' + E.Message);
    ConsoleWindowWriteLn(WindowHandle,'');
   end;
 end;

 {Let's try another type of hardware exception by trying to execute an unassigned
  function. At the same time we'll also add a try..finally block within our normal
  try..except block to see how that works.}
 try
  {Let's assign nil to our Dummy function}
  Dummy:=nil;

  {Before we call the dummy function and raise an exception, let's add a try..finally
   block. The try..finally is different from a try..except, the finally part is always
   executed, not just when an exception occurs.

   This can be really useful for making sure you release memory or free an object if
   an error occurs and even works on its own so you can use it to make sure everything
   is freed if you exit early from a function.}
  try
   {When we try to call our dummy function, to CPU will raise an exception.}
   ConsoleWindowWriteLn(WindowHandle,'Trying Data:=Dummy(123)');
   Data:=Dummy(123);

   {This line won't ever be executed}
   ConsoleWindowWriteLn(WindowHandle,'Data:=Dummy(123) Success !');
  finally
   {This should be executed even though an exception occurred}
   ConsoleWindowWriteLn(WindowHandle,'Finally, I thought you forgot about me!');
  end;
 except
  {Again we should be here after our exception is raised, print the message}
  on E: Exception do
   begin
    ConsoleWindowWriteLn(WindowHandle,'An exception happened at address ' + IntToHex(PtrUInt(ExceptAddr),8) + ' the message was ' + E.Message);
    ConsoleWindowWriteLn(WindowHandle,'');
   end;
 end;


 {Halt the thread}
 ThreadHalt(0);
end.

